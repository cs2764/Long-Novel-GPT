# APIè°ƒè¯•æ—¥å¿—ç³»ç»Ÿæ–‡æ¡£

## æ¦‚è¿°

Long-Novel-GPT 3.0 Enhanced Edition å®ç°äº†å®Œæ•´çš„APIè°ƒè¯•å’Œç›‘æ§ç³»ç»Ÿï¼Œæä¾›è¯¦ç»†çš„HTTPè¯·æ±‚å“åº”è®°å½•ã€æ€§èƒ½ç›‘æ§å’Œè´¹ç”¨ç»Ÿè®¡åŠŸèƒ½ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†æ—¥å¿—ç³»ç»Ÿçš„æ¶æ„ã€å®ç°å’Œä½¿ç”¨æ–¹æ³•ã€‚

## ç³»ç»Ÿæ¶æ„

### æ—¥å¿—ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 APIè°ƒè¯•æ—¥å¿—ç³»ç»Ÿ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   APIè°ƒç”¨å±‚      â”‚  â”‚   æ—¥å¿—è®°å½•å±‚     â”‚  â”‚  æ•°æ®å­˜å‚¨å±‚  â”‚ â”‚
â”‚  â”‚ (å„Provider API) â”‚â”€â–ºâ”‚ (Logger Module)  â”‚â”€â–ºâ”‚ (MongoDB/   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  Console)   â”‚ â”‚
â”‚                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   æ€§èƒ½ç›‘æ§       â”‚  â”‚   è´¹ç”¨ç»Ÿè®¡       â”‚  â”‚  é”™è¯¯è¿½è¸ª    â”‚ â”‚
â”‚  â”‚ (Response Time)  â”‚  â”‚ (Cost Tracking)  â”‚  â”‚ (Error Log) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚                 æ—¥å¿—èšåˆå’Œåˆ†æ                            â”‚ â”‚
â”‚  â”‚  â€¢ å®æ—¶ç›‘æ§  â€¢ ç»Ÿè®¡åˆ†æ  â€¢ å‘Šè­¦æœºåˆ¶  â€¢ æ€§èƒ½æŠ¥å‘Š        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ ¸å¿ƒæ—¥å¿—æ¨¡å—

### 1. ç»Ÿä¸€æ—¥å¿—å…¥å£

æ‰€æœ‰APIè°ƒç”¨éƒ½é€šè¿‡ç»Ÿä¸€çš„æ—¥å¿—è£…é¥°å™¨è¿›è¡Œè®°å½•ï¼š

```python
from llm_api.mongodb_cache import llm_api_cache

@llm_api_cache()
def stream_chat(model_config: ModelConfig, messages: list, response_json=False) -> Generator:
    import json
    
    print(f"\n=== LLM API Stream Chat Started ===")
    print(f"Model Config: {json.dumps(dict(model_config), default=str, ensure_ascii=False)}")
    print(f"Messages Count: {len(messages)}")
    print(f"Response JSON: {response_json}")
    
    try:
        # éªŒè¯é…ç½®
        model_config.validate()
        print(f"âœ… Model config validated successfully")
        
        # å¤„ç†ç³»ç»Ÿæç¤ºè¯
        if model_config.get('system_prompt'):
            # æ³¨å…¥ç³»ç»Ÿæç¤ºè¯é€»è¾‘
            pass
            
        # è°ƒç”¨å…·ä½“çš„API
        for result in api_call_function(model_config, messages, response_json):
            yield result
            
    except Exception as e:
        print(f"âŒ APIè°ƒç”¨å¤±è´¥: {e}")
        raise
    finally:
        print(f"=== LLM API Stream Chat Finished ===\n")
```

### 2. è¯¦ç»†çš„APIè°ƒç”¨æ—¥å¿—

æ¯ä¸ªAPIæä¾›å•†éƒ½å®ç°äº†è¯¦ç»†çš„æ—¥å¿—è®°å½•ï¼š

**OpenAI APIæ—¥å¿—ç¤ºä¾‹ï¼š**
```python
def stream_chat_with_gpt(messages, model='gpt-3.5-turbo', response_json=False, api_key=None, base_url=None, max_tokens=4096):
    import json
    import time
    
    # è¯¦ç»†æ—¥å¿—è®°å½•APIè°ƒç”¨ä¿¡æ¯
    print(f"=== OpenAI API Call Details ===")
    print(f"Model: {model}")
    print(f"Base URL: {base_url}")
    print(f"API Key: {'***' + api_key[-8:] if api_key and len(api_key) > 8 else 'None'}")
    print(f"Max Tokens: {max_tokens}")
    print(f"Response JSON: {response_json}")
    print(f"Messages Count: {len(messages)}")
    print(f"First Message: {json.dumps(messages[0] if messages else {}, ensure_ascii=False)[:200]}...")
    
    # æ„å»ºHTTPè¯·æ±‚è¯¦ç»†ä¿¡æ¯
    api_url = f"{base_url or 'https://api.openai.com/v1'}/chat/completions"
    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    if base_url and "openrouter.ai" in base_url:
        headers.update({
            "HTTP-Referer": "https://github.com/Long-Novel-GPT",
            "X-Title": "Long-Novel-GPT"
        })
    
    # æ˜¾ç¤ºHTTPè¯·æ±‚è¯¦ç»†ä¿¡æ¯
    print(f"\nğŸŒ === HTTP Request Details ===")
    print(f"URL: {api_url}")
    print(f"Method: POST")
    print(f"Headers:")
    for key, value in headers.items():
        if key.lower() == 'authorization':
            print(f"  {key}: Bearer ***{value.split()[-1][-8:]}")
        else:
            print(f"  {key}: {value}")
    
    try:
        print(f"ğŸš€ Sending request to {api_url}")
        start_time = time.time()
        
        # å‘é€è¯·æ±‚
        chatstream = client.chat.completions.create(...)
        
        print(f"âœ… API request initiated successfully in {time.time() - start_time:.2f}s")
        
        chunk_count = 0
        first_chunk_time = None
        
        for part in chatstream:
            chunk_count += 1
            if first_chunk_time is None:
                first_chunk_time = time.time()
                print(f"ğŸ“¦ First chunk received in {first_chunk_time - start_time:.2f}s")
            
            if chunk_count <= 3:  # è®°å½•å‰å‡ ä¸ªchunkç”¨äºè°ƒè¯•
                print(f"ğŸ“¦ Chunk #{chunk_count}: {str(part)[:200]}...")
            
            yield messages
        
        total_time = time.time() - start_time
        print(f"âœ… API call completed successfully in {total_time:.2f}s, received {chunk_count} chunks")
        
    except Exception as e:
        print(f"âŒ API Call Failed: {type(e).__name__}: {str(e)}")
        print(f"ğŸ“ Full traceback:")
        traceback.print_exc()
        raise
    finally:
        print(f"=== OpenAI API Call Finished ===\n")
```

### 3. æ™ºè°±AI APIæ—¥å¿—

```python
def stream_chat_with_zhipuai(messages, model='glm-4-flash', response_json=False, api_key=None, max_tokens=4096):
    import json
    import time
    
    # è¯¦ç»†æ—¥å¿—è®°å½•APIè°ƒç”¨ä¿¡æ¯
    print(f"=== ZhipuAI API Call Details ===")
    print(f"Model: {model}")
    print(f"API Key: {'***' + api_key[-8:] if api_key and len(api_key) > 8 else 'None'}")
    print(f"Max Tokens: {max_tokens}")
    print(f"Response JSON: {response_json}")
    print(f"Messages Count: {len(messages)}")
    print(f"First Message: {json.dumps(messages[0] if messages else {}, ensure_ascii=False)[:200]}...")
    
    try:
        print(f"âœ… Creating ZhipuAI client...")
        client = ZhipuAI(api_key=api_key)
        print(f"âœ… ZhipuAI client created successfully")
        
        print(f"\nğŸŒ === ZhipuAI API Request Details ===")
        print(f"Model: {model}")
        print(f"Messages Count: {len(messages)}")
        print(f"Stream: True")
        print(f"Max Tokens: {max_tokens}")
        
        # å®‰å…¨æ˜¾ç¤ºæ¶ˆæ¯å†…å®¹
        safe_messages = [
            {**msg, 'content': msg['content'][:100] + '...' if len(msg.get('content', '')) > 100 else msg.get('content', '')}
            for msg in messages
        ]
        print(f"Request Messages: {json.dumps(safe_messages, indent=2, ensure_ascii=False)}")
        print(f"=== End ZhipuAI Request Details ===\n")
        
        print(f"ğŸš€ Sending request to ZhipuAI API")
        start_time = time.time()
        
        response = client.chat.completions.create(
            model=model,
            messages=messages,
            stream=True,
            max_tokens=max_tokens
        )
        
        print(f"âœ… API request initiated successfully in {time.time() - start_time:.2f}s")
        
        chunk_count = 0
        first_chunk_time = None
        
        for chunk in response:
            chunk_count += 1
            if first_chunk_time is None:
                first_chunk_time = time.time()
                print(f"ğŸ“¦ First chunk received in {first_chunk_time - start_time:.2f}s")
            
            if chunk_count <= 3:
                print(f"ğŸ“¦ Chunk #{chunk_count}: {str(chunk)[:200]}...")
            
            yield messages
        
        total_time = time.time() - start_time
        print(f"âœ… ZhipuAI API call completed successfully in {total_time:.2f}s, received {chunk_count} chunks")
        
    except Exception as e:
        print(f"âŒ ZhipuAI API Call Failed: {type(e).__name__}: {str(e)}")
        print(f"ğŸ“ Full traceback:")
        traceback.print_exc()
        raise
    finally:
        print(f"=== ZhipuAI API Call Finished ===\n")
```

### 4. è±†åŒ…APIæ—¥å¿—

```python
def stream_chat_with_doubao(messages, model='doubao-lite-32k', endpoint_id=None, api_key=None, max_tokens=32000):
    import json
    import time
    
    # è¯¦ç»†æ—¥å¿—è®°å½•APIè°ƒç”¨ä¿¡æ¯
    print(f"=== Doubao API Call Details ===")
    print(f"Model: {model}")
    print(f"Endpoint ID: {endpoint_id}")
    print(f"API Key: {'***' + api_key[-8:] if api_key and len(api_key) > 8 else 'None'}")
    print(f"Max Tokens: {max_tokens}")
    print(f"Response JSON: {response_json}")
    print(f"Messages Count: {len(messages)}")
    
    base_url = "https://ark.cn-beijing.volces.com/api/v3"
    
    try:
        print(f"âœ… Creating Doubao client...")
        client = OpenAI(api_key=api_key, base_url=base_url)
        print(f"âœ… Doubao client created successfully")
        
        print(f"\nğŸŒ === Doubao API Request Details ===")
        print(f"Base URL: {base_url}")
        print(f"Model (Endpoint ID): {endpoint_id}")
        print(f"Messages Count: {len(messages)}")
        print(f"Stream: True")
        print(f"Response Format: {'json_object' if response_json else 'text'}")
        
        print(f"ğŸš€ Sending request to Doubao API")
        start_time = time.time()
        
        stream = client.chat.completions.create(
            model=endpoint_id,
            messages=messages,
            stream=True,
            response_format={"type": "json_object"} if response_json else None
        )
        
        print(f"âœ… API request initiated successfully in {time.time() - start_time:.2f}s")
        
        chunk_count = 0
        first_chunk_time = None
        
        for chunk in stream:
            chunk_count += 1
            if first_chunk_time is None:
                first_chunk_time = time.time()
                print(f"ğŸ“¦ First chunk received in {first_chunk_time - start_time:.2f}s")
            
            if chunk_count <= 3:
                print(f"ğŸ“¦ Chunk #{chunk_count}: {str(chunk)[:200]}...")
            
            yield messages
        
        total_time = time.time() - start_time
        print(f"âœ… Doubao API call completed successfully in {total_time:.2f}s, received {chunk_count} chunks")
        
    except Exception as e:
        print(f"âŒ Doubao API Call Failed: {type(e).__name__}: {str(e)}")
        print(f"ğŸ“ Full traceback:")
        traceback.print_exc()
        raise
    finally:
        print(f"=== Doubao API Call Finished ===\n")
```

## è´¹ç”¨ç»Ÿè®¡ç³»ç»Ÿ

### 1. è´¹ç”¨è®°å½•

```python
from llm_api.mongodb_cost import record_api_cost

def record_api_cost(messages: ChatMessages):
    """è®°å½•APIè°ƒç”¨è´¹ç”¨"""
    db = client[MONGODB_DB_NAME]
    collection = db['api_cost']

    cost_data = {
        'created_at': datetime.datetime.now(),
        'model': messages.model,
        'cost': messages.cost,
        'currency_symbol': messages.currency_symbol,
        'input_tokens': messages[:-1].count_message_tokens(),
        'output_tokens': messages[-1:].count_message_tokens(),
        'total_tokens': messages.count_message_tokens()
    }
    collection.insert_one(cost_data)
```

### 2. è´¹ç”¨é™åˆ¶æ£€æŸ¥

```python
def check_cost_limits() -> bool:
    """æ£€æŸ¥APIè°ƒç”¨è´¹ç”¨æ˜¯å¦è¶…è¿‡é™åˆ¶"""
    now = datetime.datetime.now()
    hour_ago = now - datetime.timedelta(hours=1)
    day_ago = now - datetime.timedelta(days=1)
    
    # è·å–ç»Ÿè®¡æ•°æ®
    hour_stats = get_model_cost_stats(hour_ago, now)
    day_stats = get_model_cost_stats(day_ago, now)
    
    # è®¡ç®—æ€»è´¹ç”¨å¹¶è½¬æ¢ä¸ºäººæ°‘å¸
    hour_total_rmb = sum(
        stat['total_cost'] * (API_COST_LIMITS['USD_TO_RMB_RATE'] if stat['currency_symbol'] == '$' else 1)
        for stat in hour_stats
    )
    day_total_rmb = sum(
        stat['total_cost'] * (API_COST_LIMITS['USD_TO_RMB_RATE'] if stat['currency_symbol'] == '$' else 1)
        for stat in day_stats
    )
    
    # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if hour_total_rmb >= API_COST_LIMITS['HOURLY_LIMIT_RMB']:
        print(f"è­¦å‘Šï¼šæœ€è¿‘1å°æ—¶APIè´¹ç”¨ï¼ˆï¿¥{hour_total_rmb:.2f}ï¼‰è¶…è¿‡é™åˆ¶ï¼ˆï¿¥{API_COST_LIMITS['HOURLY_LIMIT_RMB']}ï¼‰")
        raise Exception("æœ€è¿‘1å°æ—¶å†…APIè°ƒç”¨è´¹ç”¨è¶…è¿‡è®¾å®šä¸Šé™ï¼")
    
    if day_total_rmb >= API_COST_LIMITS['DAILY_LIMIT_RMB']:
        print(f"è­¦å‘Šï¼šæœ€è¿‘24å°æ—¶APIè´¹ç”¨ï¼ˆï¿¥{day_total_rmb:.2f}ï¼‰è¶…è¿‡é™åˆ¶ï¼ˆï¿¥{API_COST_LIMITS['DAILY_LIMIT_RMB']}ï¼‰")
        raise Exception("æœ€è¿‘1å¤©å†…APIè°ƒç”¨è´¹ç”¨è¶…è¿‡è®¾å®šä¸Šé™ï¼")
    
    return True
```

### 3. è´¹ç”¨ç»Ÿè®¡æŠ¥å‘Š

```python
def get_model_cost_stats(start_time, end_time):
    """è·å–æ¨¡å‹è´¹ç”¨ç»Ÿè®¡"""
    db = client[MONGODB_DB_NAME]
    collection = db['api_cost']
    
    pipeline = [
        {
            "$match": {
                "created_at": {
                    "$gte": start_time,
                    "$lte": end_time
                }
            }
        },
        {
            "$group": {
                "_id": {
                    "model": "$model",
                    "currency_symbol": "$currency_symbol"
                },
                "total_cost": {"$sum": "$cost"},
                "total_tokens": {"$sum": "$total_tokens"},
                "input_tokens": {"$sum": "$input_tokens"},
                "output_tokens": {"$sum": "$output_tokens"},
                "call_count": {"$sum": 1}
            }
        },
        {
            "$project": {
                "_id": 0,
                "model": "$_id.model",
                "currency_symbol": "$_id.currency_symbol",
                "total_cost": 1,
                "total_tokens": 1,
                "input_tokens": 1,
                "output_tokens": 1,
                "call_count": 1
            }
        }
    ]
    
    return list(collection.aggregate(pipeline))
```

## ç¼“å­˜ç³»ç»Ÿ

### 1. MongoDBç¼“å­˜è£…é¥°å™¨

```python
def llm_api_cache():
    """MongoDBç¼“å­˜è£…é¥°å™¨"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # æ£€æŸ¥è´¹ç”¨é™åˆ¶
            check_cost_limits()
            
            use_cache = kwargs.pop('use_cache', True)
            
            if not ENABLE_MONGODB_CACHE:
                use_cache = False
            
            db = client[MONGODB_DB_NAME]
            collection = db['stream_chat']
            
            # åˆ›å»ºç¼“å­˜é”®
            cache_key = create_cache_key(func.__name__, args, kwargs)
            
            # æ£€æŸ¥ç¼“å­˜
            if use_cache:
                cached_result = collection.find_one({"cache_key": cache_key})
                if cached_result:
                    print(f"âœ… Cache hit for {func.__name__}")
                    return replay_cached_response(cached_result)
            
            # æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
            print(f"ğŸš€ Cache miss, executing {func.__name__}")
            
            generator = func(*args, **kwargs)
            yields_data = []
            last_time = time.time()
            
            try:
                while True:
                    current_time = time.time()
                    value = next(generator)
                    delay = current_time - last_time
                    
                    yields_data.append({
                        'index': len(value.response),
                        'delay': delay
                    })
                    
                    last_time = current_time
                    yield value
                    
            except StopIteration as e:
                return_value = e.value
                
                # è®°å½•APIè°ƒç”¨è´¹ç”¨
                record_api_cost(return_value)
                
                # å­˜å‚¨åˆ°MongoDB
                cache_data = {
                    'created_at': datetime.datetime.now(),
                    'return_value': return_value,
                    'func_name': func.__name__,
                    'args': args,
                    'kwargs': kwargs,
                    'yields': yields_data,
                    'cache_key': cache_key,
                }
                collection.insert_one(cache_data)
                
                return return_value
            
        return wrapper
    return decorator
```

### 2. ç¼“å­˜é‡æ”¾

```python
def replay_cached_response(cached_result):
    """é‡æ”¾ç¼“å­˜çš„å“åº”"""
    yields = cached_result['yields']
    return_value = cached_result['return_value']
    
    for yield_data in yields:
        # æ¨¡æ‹ŸåŸå§‹å»¶è¿Ÿ
        delay = min(yield_data['delay'] / CACHE_REPLAY_SPEED, CACHE_REPLAY_MAX_DELAY)
        time.sleep(delay)
        
        # é‡æ„å“åº”æ¶ˆæ¯
        response_slice = return_value.response[:yield_data['index']]
        yield ChatMessages(return_value.messages[:-1] + [{'role': 'assistant', 'content': response_slice}])
    
    return return_value
```

## æ€§èƒ½ç›‘æ§

### 1. å“åº”æ—¶é—´ç›‘æ§

```python
def monitor_api_performance():
    """ç›‘æ§APIæ€§èƒ½"""
    start_time = time.time()
    
    try:
        # APIè°ƒç”¨
        result = api_call()
        
        response_time = time.time() - start_time
        
        print(f"âœ… APIè°ƒç”¨æˆåŠŸ")
        print(f"â±ï¸  å“åº”æ—¶é—´: {response_time:.2f}s")
        
        # è®°å½•æ€§èƒ½æ•°æ®
        log_performance_data({
            'response_time': response_time,
            'status': 'success',
            'timestamp': datetime.datetime.now()
        })
        
        return result
        
    except Exception as e:
        response_time = time.time() - start_time
        
        print(f"âŒ APIè°ƒç”¨å¤±è´¥")
        print(f"â±ï¸  å“åº”æ—¶é—´: {response_time:.2f}s")
        print(f"âŒ é”™è¯¯: {e}")
        
        # è®°å½•é”™è¯¯æ•°æ®
        log_performance_data({
            'response_time': response_time,
            'status': 'error',
            'error': str(e),
            'timestamp': datetime.datetime.now()
        })
        
        raise
```

### 2. é”™è¯¯ç‡ç»Ÿè®¡

```python
def get_error_rate_stats(start_time, end_time):
    """è·å–é”™è¯¯ç‡ç»Ÿè®¡"""
    db = client[MONGODB_DB_NAME]
    collection = db['api_performance']
    
    pipeline = [
        {
            "$match": {
                "timestamp": {
                    "$gte": start_time,
                    "$lte": end_time
                }
            }
        },
        {
            "$group": {
                "_id": "$status",
                "count": {"$sum": 1}
            }
        }
    ]
    
    results = list(collection.aggregate(pipeline))
    
    total_calls = sum(result['count'] for result in results)
    error_calls = sum(result['count'] for result in results if result['_id'] == 'error')
    
    error_rate = (error_calls / total_calls * 100) if total_calls > 0 else 0
    
    return {
        'total_calls': total_calls,
        'error_calls': error_calls,
        'success_calls': total_calls - error_calls,
        'error_rate': error_rate
    }
```

## å‰ç«¯æ—¥å¿—å±•ç¤º

### 1. å®æ—¶æ—¥å¿—æµ

```python
@app.route('/api/logs/stream', methods=['GET'])
def stream_logs():
    """æµå¼ä¼ è¾“æ—¥å¿—"""
    def generate():
        # è¿æ¥åˆ°æ—¥å¿—æµ
        log_stream = get_log_stream()
        
        for log_entry in log_stream:
            # æ ¼å¼åŒ–æ—¥å¿—æ¡ç›®
            formatted_log = {
                'timestamp': log_entry['timestamp'].isoformat(),
                'level': log_entry['level'],
                'message': log_entry['message'],
                'module': log_entry.get('module', 'unknown'),
                'extra': log_entry.get('extra', {})
            }
            
            yield f"data: {json.dumps(formatted_log)}\n\n"
    
    return Response(generate(), mimetype='text/event-stream')
```

### 2. æ—¥å¿—æŸ¥è¯¢æ¥å£

```python
@app.route('/api/logs', methods=['GET'])
def get_logs():
    """è·å–æ—¥å¿—åˆ—è¡¨"""
    try:
        # è§£ææŸ¥è¯¢å‚æ•°
        start_time = request.args.get('start_time')
        end_time = request.args.get('end_time')
        level = request.args.get('level')
        module = request.args.get('module')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))
        
        # æ„å»ºæŸ¥è¯¢æ¡ä»¶
        query = {}
        if start_time:
            query['timestamp'] = {'$gte': datetime.datetime.fromisoformat(start_time)}
        if end_time:
            query.setdefault('timestamp', {})['$lte'] = datetime.datetime.fromisoformat(end_time)
        if level:
            query['level'] = level
        if module:
            query['module'] = module
        
        # æŸ¥è¯¢æ—¥å¿—
        db = client[MONGODB_DB_NAME]
        collection = db['api_logs']
        
        total = collection.count_documents(query)
        logs = list(collection.find(query)
                   .sort('timestamp', -1)
                   .skip((page - 1) * per_page)
                   .limit(per_page))
        
        # æ ¼å¼åŒ–å“åº”
        return jsonify({
            'success': True,
            'logs': logs,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
```

## é…ç½®å’Œè®¾ç½®

### 1. æ—¥å¿—çº§åˆ«é…ç½®

```python
# config.py
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'

# æ—¥å¿—æ–‡ä»¶é…ç½®
LOG_FILE = os.getenv('LOG_FILE', 'app.log')
LOG_MAX_SIZE = int(os.getenv('LOG_MAX_SIZE', 10 * 1024 * 1024))  # 10MB
LOG_BACKUP_COUNT = int(os.getenv('LOG_BACKUP_COUNT', 5))

# MongoDBæ—¥å¿—é…ç½®
ENABLE_MONGODB_LOGGING = os.getenv('ENABLE_MONGODB_LOGGING', 'true').lower() == 'true'
MONGODB_LOG_COLLECTION = os.getenv('MONGODB_LOG_COLLECTION', 'api_logs')
```

### 2. æ—¥å¿—å¤„ç†å™¨è®¾ç½®

```python
import logging
import logging.handlers
from pymongo import MongoClient

def setup_logging():
    """è®¾ç½®æ—¥å¿—ç³»ç»Ÿ"""
    # åˆ›å»ºæ ¹æ—¥å¿—å™¨
    logger = logging.getLogger('lngpt')
    logger.setLevel(getattr(logging, LOG_LEVEL))
    
    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter(LOG_FORMAT)
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)
    
    # æ–‡ä»¶å¤„ç†å™¨ï¼ˆè½®è½¬ï¼‰
    file_handler = logging.handlers.RotatingFileHandler(
        LOG_FILE, maxBytes=LOG_MAX_SIZE, backupCount=LOG_BACKUP_COUNT
    )
    file_handler.setLevel(logging.DEBUG)
    file_formatter = logging.Formatter(LOG_FORMAT)
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)
    
    # MongoDBå¤„ç†å™¨
    if ENABLE_MONGODB_LOGGING:
        mongodb_handler = MongoDBHandler()
        mongodb_handler.setLevel(logging.INFO)
        logger.addHandler(mongodb_handler)
    
    return logger

class MongoDBHandler(logging.Handler):
    """MongoDBæ—¥å¿—å¤„ç†å™¨"""
    
    def __init__(self):
        super().__init__()
        self.client = MongoClient(MONGODB_URI)
        self.db = self.client[MONGODB_DB_NAME]
        self.collection = self.db[MONGODB_LOG_COLLECTION]
    
    def emit(self, record):
        """å‘é€æ—¥å¿—è®°å½•åˆ°MongoDB"""
        try:
            log_entry = {
                'timestamp': datetime.datetime.fromtimestamp(record.created),
                'level': record.levelname,
                'message': record.getMessage(),
                'module': record.module,
                'function': record.funcName,
                'line': record.lineno,
                'extra': getattr(record, 'extra', {})
            }
            
            self.collection.insert_one(log_entry)
            
        except Exception:
            # é¿å…æ—¥å¿—è®°å½•å¤±è´¥å½±å“ä¸»ç¨‹åº
            pass
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºæœ¬æ—¥å¿—è®°å½•

```python
import logging

# è·å–æ—¥å¿—å™¨
logger = logging.getLogger('lngpt.api')

# è®°å½•ä¸åŒçº§åˆ«çš„æ—¥å¿—
logger.debug("APIé…ç½®è¯¦æƒ…", extra={'config': model_config})
logger.info("å¼€å§‹APIè°ƒç”¨", extra={'model': model_name, 'tokens': token_count})
logger.warning("APIè°ƒç”¨è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•", extra={'retry_count': 2})
logger.error("APIè°ƒç”¨å¤±è´¥", extra={'error': str(e), 'traceback': traceback.format_exc()})
```

### 2. ç»“æ„åŒ–æ—¥å¿—è®°å½•

```python
def log_api_call(func):
    """APIè°ƒç”¨æ—¥å¿—è£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger = logging.getLogger('lngpt.api')
        
        # è®°å½•è°ƒç”¨å¼€å§‹
        logger.info(f"APIè°ƒç”¨å¼€å§‹: {func.__name__}", extra={
            'function': func.__name__,
            'args': str(args)[:200],
            'kwargs': str(kwargs)[:200]
        })
        
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            
            # è®°å½•è°ƒç”¨æˆåŠŸ
            duration = time.time() - start_time
            logger.info(f"APIè°ƒç”¨æˆåŠŸ: {func.__name__}", extra={
                'function': func.__name__,
                'duration': duration,
                'status': 'success'
            })
            
            return result
            
        except Exception as e:
            # è®°å½•è°ƒç”¨å¤±è´¥
            duration = time.time() - start_time
            logger.error(f"APIè°ƒç”¨å¤±è´¥: {func.__name__}", extra={
                'function': func.__name__,
                'duration': duration,
                'status': 'error',
                'error': str(e),
                'traceback': traceback.format_exc()
            })
            
            raise
    
    return wrapper
```

### 3. æ€§èƒ½ç›‘æ§æ—¥å¿—

```python
class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§ç±»"""
    
    def __init__(self):
        self.logger = logging.getLogger('lngpt.performance')
    
    def log_request(self, request_id, method, url, start_time):
        """è®°å½•è¯·æ±‚å¼€å§‹"""
        self.logger.info("è¯·æ±‚å¼€å§‹", extra={
            'request_id': request_id,
            'method': method,
            'url': url,
            'start_time': start_time
        })
    
    def log_response(self, request_id, status_code, duration, response_size):
        """è®°å½•å“åº”ç»“æŸ"""
        self.logger.info("è¯·æ±‚å®Œæˆ", extra={
            'request_id': request_id,
            'status_code': status_code,
            'duration': duration,
            'response_size': response_size
        })
    
    def log_error(self, request_id, error, duration):
        """è®°å½•è¯·æ±‚é”™è¯¯"""
        self.logger.error("è¯·æ±‚é”™è¯¯", extra={
            'request_id': request_id,
            'error': str(error),
            'duration': duration
        })
```

## ç›‘æ§å’Œå‘Šè­¦

### 1. å®æ—¶ç›‘æ§

```python
class RealTimeMonitor:
    """å®æ—¶ç›‘æ§ç±»"""
    
    def __init__(self):
        self.logger = logging.getLogger('lngpt.monitor')
        self.metrics = {
            'request_count': 0,
            'error_count': 0,
            'total_duration': 0,
            'last_reset': time.time()
        }
    
    def record_request(self, duration, success=True):
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        self.metrics['request_count'] += 1
        self.metrics['total_duration'] += duration
        
        if not success:
            self.metrics['error_count'] += 1
        
        # æ¯åˆ†é’Ÿè¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
        if time.time() - self.metrics['last_reset'] >= 60:
            self.output_metrics()
            self.reset_metrics()
    
    def output_metrics(self):
        """è¾“å‡ºç›‘æ§æŒ‡æ ‡"""
        if self.metrics['request_count'] > 0:
            avg_duration = self.metrics['total_duration'] / self.metrics['request_count']
            error_rate = self.metrics['error_count'] / self.metrics['request_count'] * 100
            
            self.logger.info("æ€§èƒ½æŒ‡æ ‡", extra={
                'request_count': self.metrics['request_count'],
                'error_count': self.metrics['error_count'],
                'error_rate': error_rate,
                'avg_duration': avg_duration,
                'total_duration': self.metrics['total_duration']
            })
    
    def reset_metrics(self):
        """é‡ç½®æŒ‡æ ‡"""
        self.metrics = {
            'request_count': 0,
            'error_count': 0,
            'total_duration': 0,
            'last_reset': time.time()
        }
```

### 2. å‘Šè­¦ç³»ç»Ÿ

```python
class AlertSystem:
    """å‘Šè­¦ç³»ç»Ÿ"""
    
    def __init__(self):
        self.logger = logging.getLogger('lngpt.alert')
        self.thresholds = {
            'error_rate': 10.0,  # é”™è¯¯ç‡è¶…è¿‡10%
            'avg_duration': 5.0,  # å¹³å‡å“åº”æ—¶é—´è¶…è¿‡5ç§’
            'request_count': 1000  # æ¯åˆ†é’Ÿè¯·æ±‚æ•°è¶…è¿‡1000
        }
    
    def check_alerts(self, metrics):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        alerts = []
        
        # æ£€æŸ¥é”™è¯¯ç‡
        if metrics.get('error_rate', 0) > self.thresholds['error_rate']:
            alerts.append({
                'type': 'error_rate',
                'message': f"é”™è¯¯ç‡è¿‡é«˜: {metrics['error_rate']:.2f}%",
                'severity': 'high'
            })
        
        # æ£€æŸ¥å“åº”æ—¶é—´
        if metrics.get('avg_duration', 0) > self.thresholds['avg_duration']:
            alerts.append({
                'type': 'response_time',
                'message': f"å“åº”æ—¶é—´è¿‡é•¿: {metrics['avg_duration']:.2f}s",
                'severity': 'medium'
            })
        
        # æ£€æŸ¥è¯·æ±‚é‡
        if metrics.get('request_count', 0) > self.thresholds['request_count']:
            alerts.append({
                'type': 'request_volume',
                'message': f"è¯·æ±‚é‡è¿‡é«˜: {metrics['request_count']}",
                'severity': 'medium'
            })
        
        # å‘é€å‘Šè­¦
        for alert in alerts:
            self.send_alert(alert)
    
    def send_alert(self, alert):
        """å‘é€å‘Šè­¦"""
        self.logger.warning(f"å‘Šè­¦: {alert['message']}", extra={
            'alert_type': alert['type'],
            'severity': alert['severity'],
            'timestamp': datetime.datetime.now()
        })
        
        # è¿™é‡Œå¯ä»¥æ·»åŠ é‚®ä»¶ã€çŸ­ä¿¡ã€webhookç­‰é€šçŸ¥æ–¹å¼
```

## æ•…éšœæ’é™¤

### 1. å¸¸è§æ—¥å¿—é—®é¢˜

**é—®é¢˜1ï¼šæ—¥å¿—æ–‡ä»¶è¿‡å¤§**
```python
# è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨è½®è½¬æ—¥å¿—
import logging.handlers

handler = logging.handlers.RotatingFileHandler(
    'app.log', maxBytes=10*1024*1024, backupCount=5
)
```

**é—®é¢˜2ï¼šMongoDBè¿æ¥å¤±è´¥**
```python
# è§£å†³æ–¹æ¡ˆï¼šæ·»åŠ è¿æ¥æ£€æŸ¥
def check_mongodb_connection():
    try:
        client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)
        client.admin.command('ping')
        return True
    except Exception as e:
        logger.error(f"MongoDBè¿æ¥å¤±è´¥: {e}")
        return False
```

**é—®é¢˜3ï¼šæ—¥å¿—æ€§èƒ½å½±å“**
```python
# è§£å†³æ–¹æ¡ˆï¼šå¼‚æ­¥æ—¥å¿—è®°å½•
import asyncio
import queue
import threading

class AsyncLogHandler(logging.Handler):
    def __init__(self):
        super().__init__()
        self.queue = queue.Queue()
        self.thread = threading.Thread(target=self._log_worker)
        self.thread.daemon = True
        self.thread.start()
    
    def emit(self, record):
        self.queue.put(record)
    
    def _log_worker(self):
        while True:
            record = self.queue.get()
            if record is None:
                break
            # å¤„ç†æ—¥å¿—è®°å½•
            self._process_record(record)
```

### 2. è°ƒè¯•æŠ€å·§

**å¯ç”¨è¯¦ç»†æ—¥å¿—ï¼š**
```bash
export LOG_LEVEL=DEBUG
export LNGPT_DEBUG=1
python app.py
```

**æŸ¥çœ‹ç‰¹å®šæ¨¡å—æ—¥å¿—ï¼š**
```python
# åªæ˜¾ç¤ºAPIç›¸å…³æ—¥å¿—
logger = logging.getLogger('lngpt.api')
logger.setLevel(logging.DEBUG)
```

**å®æ—¶ç›‘æ§æ—¥å¿—ï¼š**
```bash
# å®æ—¶æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶
tail -f app.log

# ä½¿ç”¨grepè¿‡æ»¤
tail -f app.log | grep ERROR
```

## æ€»ç»“

APIè°ƒè¯•æ—¥å¿—ç³»ç»Ÿä¸ºLong-Novel-GPTæä¾›äº†å®Œæ•´çš„ç›‘æ§å’Œè°ƒè¯•èƒ½åŠ›ï¼š

- **è¯¦ç»†çš„APIè°ƒç”¨æ—¥å¿—**ï¼šè®°å½•å®Œæ•´çš„HTTPè¯·æ±‚å“åº”ä¿¡æ¯
- **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶è·Ÿè¸ªå“åº”æ—¶é—´å’Œé”™è¯¯ç‡
- **è´¹ç”¨ç»Ÿè®¡**ï¼šå‡†ç¡®è®°å½•å’Œé™åˆ¶APIè°ƒç”¨è´¹ç”¨
- **ç¼“å­˜ç³»ç»Ÿ**ï¼šæé«˜æ€§èƒ½å¹¶å‡å°‘APIè°ƒç”¨æ¬¡æ•°
- **å®æ—¶ç›‘æ§**ï¼šæ”¯æŒå®æ—¶æ—¥å¿—æµå’Œå‘Šè­¦ç³»ç»Ÿ
- **å¤šç§å­˜å‚¨æ–¹å¼**ï¼šæ”¯æŒæ–‡ä»¶ã€MongoDBç­‰å¤šç§æ—¥å¿—å­˜å‚¨
- **çµæ´»çš„é…ç½®**ï¼šæ”¯æŒä¸åŒæ—¥å¿—çº§åˆ«å’Œè¾“å‡ºæ ¼å¼

è¿™ä¸ªç³»ç»Ÿä¸ºå¼€å‘è€…æä¾›äº†å¼ºå¤§çš„è°ƒè¯•å’Œç›‘æ§å·¥å…·ï¼Œç¡®ä¿ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œæ€§èƒ½ã€‚ 